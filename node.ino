/*
  PUBLIC-NODE Captive Portal + Metrics + Persistent Chat (SPIFFS)
  Target: ESP32-C6 (Arduino core)

  Features:
  - SoftAP SSID "PUBLIC-NODE" (open)
  - Captive portal behavior via DNS wildcard + HTTP redirects
  - Metrics page: remembers MAC addresses that connected in the past (SPIFFS)
  - Chat: stores messages in SPIFFS for future visitors
  - LED blink: 0.5s period, PWM ~50% brightness when ON

  Notes:
  - LED pin varies by board. Uses LED_BUILTIN if defined, else defaults to GPIO8.
  - Use a partition scheme that includes SPIFFS (Tools -> Partition Scheme).
*/

#include <WiFi.h>
#include <WebServer.h>
#include <DNSServer.h>
#include <SPIFFS.h>
#include "esp_arduino_version.h"  // add this near your other includes
#include "esp_wifi.h"

#if __has_include("esp_wifi_ap_get_sta_list.h")
  #include "esp_wifi_ap_get_sta_list.h"
  #define HAS_STA_IP_MAP 1
#else
  #define HAS_STA_IP_MAP 0
#endif

#include "esp_netif_ip_addr.h"   // esp_ip4addr_ntoa()

#ifndef LED_BUILTIN
// Many ESP32-C6 dev boards have an LED on GPIO8; change if needed.
#define LED_BUILTIN 8
#endif

// Forward declarations for Arduino's autogenerated prototypes.
struct SessionLoc;

// ---------- User Config ----------
static const char* AP_SSID = "PUBLIC-NODE";

// LED blink behavior
static const uint32_t BLINK_PERIOD_MS = 500;     // full cycle = 500ms (250ms on, 250ms off)
static const uint32_t ON_TIME_MS      = 250;     // on-time within the 500ms cycle
static const uint8_t  PWM_RES_BITS    = 8;       // 0..255
static const uint32_t PWM_FREQ_HZ     = 5000;
static const uint8_t  PWM_CHANNEL     = 0;       // LEDC channel
static const uint8_t  HALF_DUTY       = 51;      // ~20% of 255 (255*0.20=51)

// Storage limits
static const size_t MAX_DEVICES  = 100;
static const size_t MAX_MESSAGES = 25;
static const size_t MAX_MSG_LEN  = 160;

// Files in SPIFFS
static const char* DEVICES_FILE  = "/devices.csv";   // mac,count,lastSeenMs
// Files in SPIFFS (v2 formats)
static const char* USERS_FILE    = "/users.csv";         // mac,username
static const char* NODELOC_FILE  = "/node_location.csv"; // lat,lon,acc,reported_by_mac,last_ms
static const char* MESSAGES_FILE = "/messages_v2.log";   // t|mac|user|lat|lon|acc|msg  (pipe-delimited)

// Username limits
static const size_t MAX_NAME_LEN = 24;
// ---------- Networking ----------
DNSServer dnsServer;
WebServer server(80);

IPAddress apIP(192, 168, 4, 1);
IPAddress gateway(192, 168, 4, 1);
IPAddress subnet(255, 255, 255, 0);

// ---------- Data Structures ----------
struct DeviceEntry {
  String mac;
  uint32_t count;
  uint32_t lastSeenMs;
};

DeviceEntry devices[MAX_DEVICES];
size_t deviceCount = 0;

// ---------- Helpers ----------
String macToString(const uint8_t mac[6]) {
  char buf[18];
  snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(buf);
}

String jsonEscape(const String& s) {
  String out;
  out.reserve(s.length() + 8);
  for (size_t i = 0; i < s.length(); i++) {
    char c = s[i];
    switch (c) {
      case '\\': out += "\\\\"; break;
      case '\"': out += "\\\""; break;
      case '\n': out += "\\n";  break;
      case '\r': out += "\\r";  break;
      case '\t': out += "\\t";  break;
      default:
        if ((uint8_t)c < 0x20) {
          // drop other control chars
        } else {
          out += c;
        }
    }
  }
  return out;
}

struct UserEntry {
  String mac;
  String name;
};
static UserEntry users[MAX_DEVICES];
static size_t userCount = 0;

struct NodeLoc {
  bool has = false;
  float lat = 0, lon = 0, acc = 0;
  String byMac = "";
  uint32_t lastMs = 0;
};
static NodeLoc nodeLoc;

struct SessionLoc {
  bool has = false;
  String mac = "";
  float lat = 0, lon = 0, acc = 0;
  uint32_t lastMs = 0;
};

static SessionLoc sessionLocs[MAX_DEVICES];
static size_t sessionLocCount = 0;

String sanitizeField(String s, size_t maxLen) {
  s.replace("\r", " ");
  s.replace("\n", " ");
  s.replace("|", " ");     // delimiter safety
  s.trim();
  if (s.length() > maxLen) s = s.substring(0, maxLen);
  return s;
}

int findUserIndex(const String& mac) {
  for (size_t i = 0; i < userCount; i++) if (users[i].mac == mac) return (int)i;
  return -1;
}

void loadUsersFromSPIFFS() {
  userCount = 0;
  if (!SPIFFS.exists(USERS_FILE)) {
    File nf = SPIFFS.open(USERS_FILE, FILE_WRITE);
    if (nf) nf.close();
    return;
  }
  File f = SPIFFS.open(USERS_FILE, FILE_READ);
  if (!f) return;

  while (f.available() && userCount < MAX_DEVICES) {
    String line = f.readStringUntil('\n');
    line.trim();
    if (!line.length()) continue;
    int c = line.indexOf(',');
    if (c < 0) continue;
    String mac = line.substring(0, c); mac.trim();
    String nm  = line.substring(c + 1); nm.trim();
    if (mac.length() < 11) continue;
    users[userCount].mac = mac;
    users[userCount].name = nm;
    userCount++;
  }
  f.close();
}

void saveUsersToSPIFFS() {
  File f = SPIFFS.open(USERS_FILE, FILE_WRITE);
  if (!f) return;
  for (size_t i = 0; i < userCount; i++) {
    f.print(users[i].mac); f.print(",");
    f.println(users[i].name);
  }
  f.close();
}

String getUsernameForMac(const String& mac) {
  if (mac == "UNKNOWN") return "";
  int idx = findUserIndex(mac);
  if (idx >= 0) return users[idx].name;
  return "";
}

void setUsernameForMac(const String& mac, const String& name) {
  if (mac == "UNKNOWN") return;
  int idx = findUserIndex(mac);
  if (idx >= 0) {
    users[idx].name = name;
  } else {
    if (userCount >= MAX_DEVICES) return;
    users[userCount].mac = mac;
    users[userCount].name = name;
    userCount++;
  }
  saveUsersToSPIFFS();
}

int findSessionLocIndex(const String& mac) {
  for (size_t i = 0; i < sessionLocCount; i++) {
    if (sessionLocs[i].mac == mac) return (int)i;
  }
  return -1;
}

bool getSessionLoc(const String& mac, SessionLoc& out) {
  int idx = findSessionLocIndex(mac);
  if (idx < 0 || !sessionLocs[idx].has) return false;
  out = sessionLocs[idx];
  return true;
}

void setSessionLoc(const String& mac, float lat, float lon, float acc) {
  uint32_t nowMs = millis();
  int idx = findSessionLocIndex(mac);

  if (idx >= 0) {
    sessionLocs[idx].has = true;
    sessionLocs[idx].lat = lat;
    sessionLocs[idx].lon = lon;
    sessionLocs[idx].acc = acc;
    sessionLocs[idx].lastMs = nowMs;
    return;
  }

  if (sessionLocCount >= MAX_DEVICES) return;

  sessionLocs[sessionLocCount].has = true;
  sessionLocs[sessionLocCount].mac = mac;
  sessionLocs[sessionLocCount].lat = lat;
  sessionLocs[sessionLocCount].lon = lon;
  sessionLocs[sessionLocCount].acc = acc;
  sessionLocs[sessionLocCount].lastMs = nowMs;
  sessionLocCount++;
}

void loadNodeLocFromSPIFFS() {
  nodeLoc = NodeLoc{};
  if (!SPIFFS.exists(NODELOC_FILE)) {
    File nf = SPIFFS.open(NODELOC_FILE, FILE_WRITE);
    if (nf) nf.close();
    return;
  }
  File f = SPIFFS.open(NODELOC_FILE, FILE_READ);
  if (!f) return;
  String line = f.readStringUntil('\n');
  f.close();
  line.trim();
  if (!line.length()) return;

  // lat,lon,acc,mac,lastms
  int c1 = line.indexOf(',');
  int c2 = line.indexOf(',', c1 + 1);
  int c3 = line.indexOf(',', c2 + 1);
  int c4 = line.indexOf(',', c3 + 1);
  if (c1 < 0 || c2 < 0 || c3 < 0 || c4 < 0) return;

  nodeLoc.lat = line.substring(0, c1).toFloat();
  nodeLoc.lon = line.substring(c1 + 1, c2).toFloat();
  nodeLoc.acc = line.substring(c2 + 1, c3).toFloat();
  nodeLoc.byMac = line.substring(c3 + 1, c4); nodeLoc.byMac.trim();
  nodeLoc.lastMs = (uint32_t)line.substring(c4 + 1).toInt();
  nodeLoc.has = true;
}

void saveNodeLocToSPIFFS() {
  File f = SPIFFS.open(NODELOC_FILE, FILE_WRITE);
  if (!f) return;
  if (nodeLoc.has) {
    f.print(String(nodeLoc.lat, 6)); f.print(",");
    f.print(String(nodeLoc.lon, 6)); f.print(",");
    f.print(String(nodeLoc.acc, 1)); f.print(",");
    f.print(nodeLoc.byMac); f.print(",");
    f.println(nodeLoc.lastMs);
  }
  f.close();
}

// ---- Map HTTP client IP -> station MAC (best-effort) ----
String clientMacFromRequest() {
  IPAddress rip = server.client().remoteIP();
  String ripStr = rip.toString();

#if HAS_STA_IP_MAP
  wifi_sta_list_t wifiList;
  wifi_sta_mac_ip_list_t macIpList;
  memset(&wifiList, 0, sizeof(wifiList));
  memset(&macIpList, 0, sizeof(macIpList));

  if (esp_wifi_ap_get_sta_list(&wifiList) != ESP_OK) return "UNKNOWN";
  if (esp_wifi_ap_get_sta_list_with_ip(&wifiList, &macIpList) != ESP_OK) return "UNKNOWN";

  char ipbuf[16];
  for (int i = 0; i < macIpList.num; i++) {
    if (!esp_ip4addr_ntoa(&macIpList.sta[i].ip, ipbuf, sizeof(ipbuf))) continue;
    if (ripStr == String(ipbuf)) {
      return macToString(macIpList.sta[i].mac);
    }
  }
#endif

  return "UNKNOWN";
}

// ---- Messages v2: t|mac|user|lat|lon|acc|msg ----
void appendMessageV2(const String& mac, const String& user, bool hasLoc, float lat, float lon, float acc, const String& msgRaw) {
  String msg = sanitizeField(msgRaw, MAX_MSG_LEN);
  if (!msg.length()) return;

  String u = sanitizeField(user, MAX_NAME_LEN);

  if (!SPIFFS.exists(MESSAGES_FILE)) {
    File nf = SPIFFS.open(MESSAGES_FILE, FILE_WRITE);
    if (nf) nf.close();
  }

  File f = SPIFFS.open(MESSAGES_FILE, FILE_APPEND);
  if (!f) return;

  uint32_t t = millis();
  f.print(t); f.print("|");
  f.print(mac); f.print("|");
  f.print(u); f.print("|");
  if (hasLoc) {
    f.print(String(lat, 6)); f.print("|");
    f.print(String(lon, 6)); f.print("|");
    f.print(String(acc, 1)); f.print("|");
  } else {
    f.print("|"); f.print("|"); f.print("|");
  }
  f.println(msg);
  f.close();

  trimMessagesIfNeeded(); // keep your existing trimming routine (it counts lines)
}

int findDeviceIndex(const String& mac) {
  for (size_t i = 0; i < deviceCount; i++) {
    if (devices[i].mac == mac) return (int)i;
  }
  return -1;
}

void saveDevicesToSPIFFS() {
  File f = SPIFFS.open(DEVICES_FILE, FILE_WRITE);
  if (!f) return;

  for (size_t i = 0; i < deviceCount; i++) {
    f.print(devices[i].mac); f.print(",");
    f.print(devices[i].count); f.print(",");
    f.println(devices[i].lastSeenMs);
  }
  f.close();
}

void loadDevicesFromSPIFFS() {
  deviceCount = 0;

  if (!SPIFFS.exists(DEVICES_FILE)) {
    File nf = SPIFFS.open(DEVICES_FILE, FILE_WRITE);
    if (nf) nf.close();
    return;
  }

  File f = SPIFFS.open(DEVICES_FILE, FILE_READ);
  if (!f) return;

  while (f.available() && deviceCount < MAX_DEVICES) {
    String line = f.readStringUntil('\n');
    line.trim();
    if (line.length() == 0) continue;

    int c1 = line.indexOf(',');
    int c2 = line.indexOf(',', c1 + 1);
    if (c1 < 0 || c2 < 0) continue;

    String mac = line.substring(0, c1);
    String cnt = line.substring(c1 + 1, c2);
    String lst = line.substring(c2 + 1);

    mac.trim(); cnt.trim(); lst.trim();
    if (mac.length() < 11) continue;

    devices[deviceCount].mac = mac;
    devices[deviceCount].count = (uint32_t)cnt.toInt();
    devices[deviceCount].lastSeenMs = (uint32_t)lst.toInt();
    deviceCount++;
  }

  f.close();
}

void upsertDeviceSeen(const String& mac) {
  uint32_t nowMs = millis();
  int idx = findDeviceIndex(mac);

  if (idx >= 0) {
    devices[idx].count++;
    devices[idx].lastSeenMs = nowMs;
  } else {
    if (deviceCount >= MAX_DEVICES) {
      // simple policy: overwrite the oldest entry
      size_t oldest = 0;
      for (size_t i = 1; i < deviceCount; i++) {
        if (devices[i].lastSeenMs < devices[oldest].lastSeenMs) oldest = i;
      }
      devices[oldest].mac = mac;
      devices[oldest].count = 1;
      devices[oldest].lastSeenMs = nowMs;
    } else {
      devices[deviceCount].mac = mac;
      devices[deviceCount].count = 1;
      devices[deviceCount].lastSeenMs = nowMs;
      deviceCount++;
    }
  }

  saveDevicesToSPIFFS();
}

size_t countLinesInFile(const char* path) {
  File f = SPIFFS.open(path, FILE_READ);
  if (!f) return 0;
  size_t lines = 0;
  while (f.available()) {
    String line = f.readStringUntil('\n');
    (void)line;
    lines++;
  }
  f.close();
  return lines;
}

void trimMessagesIfNeeded() {
  size_t lines = countLinesInFile(MESSAGES_FILE);
  if (lines <= MAX_MESSAGES) return;

  // Keep only the last MAX_MESSAGES lines
  File f = SPIFFS.open(MESSAGES_FILE, FILE_READ);
  if (!f) return;

  // Read all into a ring buffer of Strings
  String ring[MAX_MESSAGES];
  size_t idx = 0;
  size_t total = 0;

  while (f.available()) {
    String line = f.readStringUntil('\n');
    line.trim();
    ring[idx] = line;
    idx = (idx + 1) % MAX_MESSAGES;
    total++;
  }
  f.close();

  File w = SPIFFS.open(MESSAGES_FILE, FILE_WRITE);
  if (!w) return;

  size_t start = (total >= MAX_MESSAGES) ? idx : 0;
  size_t count = (total >= MAX_MESSAGES) ? MAX_MESSAGES : total;

  for (size_t i = 0; i < count; i++) {
    size_t j = (start + i) % MAX_MESSAGES;
    if (ring[j].length() > 0) w.println(ring[j]);
  }
  w.close();
}

void appendMessage(const String& rawMsg) {
  String msg = rawMsg;
  msg.replace("\r", " ");
  msg.replace("\n", " ");
  msg.trim();
  if (msg.length() == 0) return;
  if (msg.length() > MAX_MSG_LEN) msg = msg.substring(0, MAX_MSG_LEN);

  if (!SPIFFS.exists(MESSAGES_FILE)) {
    File nf = SPIFFS.open(MESSAGES_FILE, FILE_WRITE);
    if (nf) nf.close();
  }

  File f = SPIFFS.open(MESSAGES_FILE, FILE_APPEND);
  if (!f) return;
  f.println(msg);
  f.close();

  trimMessagesIfNeeded();
}

// ---------- Captive Portal / Web UI ----------
String pageHtml() {
  String ip = WiFi.softAPIP().toString();

  String html;
  html.reserve(5000);
  html += F(
    "<!doctype html><html><head>"
    "<meta charset='utf-8'/>"
    "<meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover'/>"
    "<meta name='apple-mobile-web-app-capable' content='yes'/>"
    "<title>PUBLIC-NODE</title>"
    "<style>"
    "html,body{touch-action:pan-x pan-y;overscroll-behavior:none}"
    "body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:16px;max-width:900px}"
    ".card{border:1px solid #ddd;border-radius:12px;padding:14px;margin:12px 0}"
    "h1{margin:0 0 6px 0;font-size:22px}"
    "small{color:#555}"
    "table{width:100%;border-collapse:collapse}"
    "th,td{border-bottom:1px solid #eee;padding:8px;text-align:left;font-size:14px}"
    "th{background:#fafafa}"
    ".muted{color:#666}"
    ".row{display:flex;gap:12px;flex-wrap:wrap}"
    ".col{flex:1;min-width:260px}"
    "input[type=text]{width:100%;box-sizing:border-box;padding:10px;border:1px solid #ccc;border-radius:10px;font-size:14px}"
    "button{padding:10px 12px;border:0;border-radius:10px;background:#111;color:#fff;font-size:14px;cursor:pointer}"
    "button:active{transform:translateY(1px)}"
    "pre{white-space:pre-wrap;word-break:break-word;background:#f7f7f7;padding:10px;border-radius:10px}"
    "</style>"
    "</head><body>"
  );

  html += "<h1>PUBLIC-NODE</h1>";
  html += "<small>Captive portal @ <b>" + ip + "</b> (open network)</small>";

  html += F("<div class='row'>");

  // Metrics
  html += F("<div class='card col'>"
            "<h2 style='margin:0 0 8px 0;font-size:18px'>Metrics</h2>"
            "<div class='muted'>Known devices (ever connected): <span id='knownCount'>...</span><br/>"
            "Currently connected (approx): <span id='curCount'>...</span></div>"
            "<div style='margin-top:10px;overflow:auto;max-height:320px'>"
            "<table><thead><tr><th>MAC</th><th>Count</th><th>Last Seen (ms since boot)</th></tr></thead>"
            "<tbody id='devRows'><tr><td colspan='3' class='muted'>Loading…</td></tr></tbody>"
            "</table></div>"
            "</div>");

  // Chat
html += F("<div class='card col'>"
          "<h2 style='margin:0 0 8px 0;font-size:18px'>Chat</h2>"

          "<div class='muted'>Your device: <span id='meMac'>…</span></div>"
          "<div style='display:flex;gap:8px;margin-top:8px'>"
            "<input id='name' type='text' maxlength='24' placeholder='Username (saved per device)'/>"
            "<button id='saveName' type='button'>Save</button>"
          "</div>"

          "<div class='muted' style='margin-top:10px'>"
            "Node location: <span id='nodeLoc'>(unknown)</span>"
          "</div>"
          "<div style='display:flex;justify-content:flex-end;margin-top:8px'>"
            "<button id='shareLoc' type='button'>Share GPS</button>"
          "</div>"

          "<form id='chatForm' style='margin-top:10px'>"
            "<input id='msg' type='text' name='msg' maxlength='160' placeholder='Type a short message…'/>"
            "<div style='display:flex;justify-content:flex-end;margin-top:10px'>"
              "<button type='submit'>Send</button>"
            "</div>"
          "</form>"

          "<div style='margin-top:12px'>"
          "<div class='muted' style='margin-bottom:6px'>Recent messages</div>"
          "<pre id='msgs'>Loading…</pre>"
          "</div></div>");

  html += F("</div>"); // row

  html += F(
  "<script>"

  // --- No zoom / no pinch / no double-tap ---
  "document.addEventListener('gesturestart',function(e){e.preventDefault();},{passive:false});"
  "document.addEventListener('gesturechange',function(e){e.preventDefault();},{passive:false});"
  "document.addEventListener('gestureend',function(e){e.preventDefault();},{passive:false});"
  "let lastTouchEnd=0;"
  "document.addEventListener('touchend',function(e){const now=Date.now();if(now-lastTouchEnd<=300){e.preventDefault();}lastTouchEnd=now;},{passive:false});"
  "document.addEventListener('wheel',function(e){if(e.ctrlKey||e.metaKey)e.preventDefault();},{passive:false});"

  "const $=id=>document.getElementById(id);"

  "async function post(url, obj){"
    "const body=new URLSearchParams(obj);"
    "return fetch(url,{method:'POST',headers:{"
      "'Content-Type':'application/x-www-form-urlencoded',"
      "'X-Requested-With':'fetch'"
    "},body});"
  "}"

  "function renderNodeLoc(n){"
    "if(!n){$('nodeLoc').textContent='(unknown)'; return;}"
    "const s=`${n.lat.toFixed(6)}, ${n.lon.toFixed(6)} (±${n.acc.toFixed(1)}m) by ${n.by_mac}`;"
    "$('nodeLoc').textContent=s;"
  "}"

  "async function loadMe(){"
    "try{"
      "const r=await fetch('/me',{cache:'no-store'});"
      "const me=await r.json();"
      "$('meMac').textContent=me.mac || 'UNKNOWN';"
      "$('name').value=me.username || '';"
      "renderNodeLoc(me.node_location);"
    "}catch(e){console.log(e);}"
  "}"

  "async function saveName(){"
    "const name=$('name').value.trim();"
    "if(!name) return;"
    "try{ await post('/setname',{name}); }catch(e){console.log(e);}"
  "}"

  "async function shareLoc(){"
    "if(!navigator.geolocation){ alert('Geolocation not available'); return; }"
    "navigator.geolocation.getCurrentPosition(async (pos)=>{"
      "const lat=pos.coords.latitude;"
      "const lon=pos.coords.longitude;"
      "const acc=pos.coords.accuracy || 0;"
      "try{ await post('/setloc',{lat:String(lat),lon:String(lon),acc:String(acc)}); }catch(e){console.log(e);}"
      "await loadMe();"
    "}, (err)=>{"
      "console.log(err);"
      "alert('Location permission denied or unavailable');"
    "}, {enableHighAccuracy:true, timeout:8000, maximumAge:0});"
  "}"

  "async function refresh(){"
    "try{"
      "const r=await fetch('/data',{cache:'no-store'});"
      "const j=await r.json();"
      "document.getElementById('knownCount').textContent=j.known_devices.length;"
      "document.getElementById('curCount').textContent=j.current_stations;"
      "const tb=document.getElementById('devRows');"
      "tb.innerHTML='';"
      "if(j.known_devices.length===0){"
        "tb.innerHTML='<tr><td colspan=3 class=muted>No devices yet.</td></tr>';"
      "}else{"
        "for(const d of j.known_devices){"
          "const tr=document.createElement('tr');"
          "tr.innerHTML=`<td>${d.mac}</td><td>${d.count}</td><td>${d.last_seen_ms}</td>`;"
          "tb.appendChild(tr);"
        "}"
      "}"

      // messages as objects
      "if(!j.messages || !j.messages.length){"
        "$('msgs').textContent='(no messages yet)';"
      "}else{"
        "const lines=j.messages.map(m=>{"
          "const who=(m.user && m.user.length)?m.user:'anon';"
          "const loc=(m.lat!=null && m.lon!=null)?` @ ${Number(m.lat).toFixed(5)},${Number(m.lon).toFixed(5)} (±${Number(m.acc||0).toFixed(0)}m)`:'';"
          "return `${who} (${m.mac})${loc}: ${m.msg}`;"
        "});"
        "$('msgs').textContent=lines.join('\\n');"
      "}"
    "}catch(e){console.log(e);}"
  "}"

  "document.addEventListener('DOMContentLoaded', async ()=>{"
    "await loadMe();"
    "await refresh();"
    "setInterval(refresh, 5000);"

    // request GPS once on load (will prompt on many devices)
    "setTimeout(()=>{ try{ shareLoc(); }catch(e){} }, 600);"

    "$('saveName').addEventListener('click', saveName);"
    "$('shareLoc').addEventListener('click', shareLoc);"

    "$('chatForm').addEventListener('submit', async (e)=>{"
      "e.preventDefault();"
      "await saveName();"
      "const msg=$('msg').value.trim();"
      "if(!msg) return;"
      "try{ await post('/chat',{msg}); }catch(err){console.log(err);}"
      "$('msg').value='';"
      "await refresh();"
    "});"
  "});"

  "</script>"
);

  html += F("</body></html>");
  return html;
}

void sendNoCacheHeaders() {
  server.sendHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  server.sendHeader("Pragma", "no-cache");
  server.sendHeader("Expires", "0");
}

void redirectToPortal() {
  IPAddress ip = WiFi.softAPIP();
  server.sendHeader("Location", String("http://") + ip.toString() + "/");
  sendNoCacheHeaders();
  server.send(302, "text/plain", "Redirecting to captive portal…");
}

void handleMe() {
  sendNoCacheHeaders();

  String mac = clientMacFromRequest();
  String uname = getUsernameForMac(mac);

  SessionLoc sl;
  bool hasSessionLoc = getSessionLoc(mac, sl);

  String out;
  out.reserve(512);
  out += "{";
  out += "\"mac\":\"" + mac + "\",";
  out += "\"username\":\"" + jsonEscape(uname) + "\",";
  out += "\"session_location\":";
  if (hasSessionLoc) {
    out += "{";
    out += "\"lat\":" + String(sl.lat, 6) + ",";
    out += "\"lon\":" + String(sl.lon, 6) + ",";
    out += "\"acc\":" + String(sl.acc, 1) + ",";
    out += "\"last_ms\":" + String(sl.lastMs);
    out += "}";
  } else {
    out += "null";
  }
  out += ",\"node_location\":";
  if (nodeLoc.has) {
    out += "{";
    out += "\"lat\":" + String(nodeLoc.lat, 6) + ",";
    out += "\"lon\":" + String(nodeLoc.lon, 6) + ",";
    out += "\"acc\":" + String(nodeLoc.acc, 1) + ",";
    out += "\"by_mac\":\"" + nodeLoc.byMac + "\",";
    out += "\"last_ms\":" + String(nodeLoc.lastMs);
    out += "}";
  } else {
    out += "null";
  }
  out += "}";

  server.send(200, "application/json", out);
}

void handleSetName() {
  sendNoCacheHeaders();

  String mac = clientMacFromRequest();
  String name = server.hasArg("name") ? server.arg("name") : "";
  name = sanitizeField(name, MAX_NAME_LEN);

  if (name.length()) setUsernameForMac(mac, name);

  // AJAX-friendly response
  server.send(200, "application/json", "{\"ok\":true}");
}

void handleSetLoc() {
  sendNoCacheHeaders();

  String mac = clientMacFromRequest();
  float lat = server.hasArg("lat") ? server.arg("lat").toFloat() : 0;
  float lon = server.hasArg("lon") ? server.arg("lon").toFloat() : 0;
  float acc = server.hasArg("acc") ? server.arg("acc").toFloat() : 0;

  // basic sanity
  if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
    server.send(400, "application/json", "{\"ok\":false,\"err\":\"bad_range\"}");
    return;
  }

  setSessionLoc(mac, lat, lon, acc);

  // update global node location (attested)
  nodeLoc.has = true;
  nodeLoc.lat = lat;
  nodeLoc.lon = lon;
  nodeLoc.acc = acc;
  nodeLoc.byMac = mac;
  nodeLoc.lastMs = millis();
  saveNodeLocToSPIFFS();

  server.send(200, "application/json", "{\"ok\":true}");
}

void handleRoot() {
  sendNoCacheHeaders();
  server.send(200, "text/html", pageHtml());
}

void handleData() {
  sendNoCacheHeaders();

  String out;
  out.reserve(8192);
  out += "{";

  out += "\"ap_ip\":\"" + WiFi.softAPIP().toString() + "\",";
  out += "\"current_stations\":" + String(WiFi.softAPgetStationNum()) + ",";

  // devices (keep as before)
  out += "\"known_devices\":[";
  for (size_t i = 0; i < deviceCount; i++) {
    if (i) out += ",";
    out += "{";
    out += "\"mac\":\"" + devices[i].mac + "\",";
    out += "\"count\":" + String(devices[i].count) + ",";
    out += "\"last_seen_ms\":" + String(devices[i].lastSeenMs);
    out += "}";
  }
  out += "],";

  // messages v2 objects
  out += "\"messages\":[";
  bool first = true;

  if (SPIFFS.exists(MESSAGES_FILE)) {
    File f = SPIFFS.open(MESSAGES_FILE, FILE_READ);
    if (f) {
      while (f.available()) {
        String line = f.readStringUntil('\n');
        line.trim();
        if (!line.length()) continue;

        // t|mac|user|lat|lon|acc|msg
        int p1 = line.indexOf('|');
        int p2 = line.indexOf('|', p1 + 1);
        int p3 = line.indexOf('|', p2 + 1);
        int p4 = line.indexOf('|', p3 + 1);
        int p5 = line.indexOf('|', p4 + 1);
        int p6 = line.indexOf('|', p5 + 1);
        if (p1 < 0 || p2 < 0 || p3 < 0 || p4 < 0 || p5 < 0 || p6 < 0) continue;

        String t   = line.substring(0, p1);
        String mac = line.substring(p1 + 1, p2);
        String usr = line.substring(p2 + 1, p3);
        String lat = line.substring(p3 + 1, p4);
        String lon = line.substring(p4 + 1, p5);
        String acc = line.substring(p5 + 1, p6);
        String msg = line.substring(p6 + 1);

        if (!first) out += ",";
        first = false;

        out += "{";
        out += "\"t\":" + String((uint32_t)t.toInt()) + ",";
        out += "\"mac\":\"" + jsonEscape(mac) + "\",";
        out += "\"user\":\"" + jsonEscape(usr) + "\",";
        if (lat.length() && lon.length()) {
          out += "\"lat\":" + lat + ",";
          out += "\"lon\":" + lon + ",";
          out += "\"acc\":" + (acc.length() ? acc : "0") + ",";
        } else {
          out += "\"lat\":null,\"lon\":null,\"acc\":null,";
        }
        out += "\"msg\":\"" + jsonEscape(msg) + "\"";
        out += "}";
      }
      f.close();
    }
  }
  out += "]";

  out += "}";

  server.send(200, "application/json", out);
}

void handleChatPost() {
  String msg = server.hasArg("msg") ? server.arg("msg") : "";
  String mac = clientMacFromRequest();
  String uname = getUsernameForMac(mac);

  SessionLoc sl;
  bool hasLoc = getSessionLoc(mac, sl);

  appendMessageV2(mac, uname, hasLoc, sl.lat, sl.lon, sl.acc, msg);

  // If form-submitted, redirect; if fetch(), return JSON
  String xrw = server.header("X-Requested-With");
  if (xrw.length()) {
    sendNoCacheHeaders();
    server.send(200, "application/json", "{\"ok\":true}");
  } else {
    redirectToPortal();
  }
}

// Some OS captive-check endpoints (we’ll redirect them to the portal)
void handleCaptiveEndpoints() {
  redirectToPortal();
}

void handleNotFound() {
  // If someone hits any other hostname/path, always redirect to portal
  redirectToPortal();
}

// ---------- WiFi event handling (AP station connect) ----------
#if defined(ESP_ARDUINO_VERSION_MAJOR) && (ESP_ARDUINO_VERSION_MAJOR >= 3)
  #define WIFI_AP_STACONNECTED_EVENT    ARDUINO_EVENT_WIFI_AP_STACONNECTED
  #define WIFI_AP_STADISCONNECTED_EVENT ARDUINO_EVENT_WIFI_AP_STADISCONNECTED
#else
  #define WIFI_AP_STACONNECTED_EVENT    SYSTEM_EVENT_AP_STACONNECTED
  #define WIFI_AP_STADISCONNECTED_EVENT SYSTEM_EVENT_AP_STADISCONNECTED
#endif

void WiFiEvent(WiFiEvent_t event, WiFiEventInfo_t info) {
  if (event == WIFI_AP_STACONNECTED_EVENT) {
    uint8_t* macPtr = nullptr;

    #if defined(ESP_ARDUINO_VERSION_MAJOR) && (ESP_ARDUINO_VERSION_MAJOR >= 3)
      macPtr = info.wifi_ap_staconnected.mac;
    #else
      macPtr = info.sta_connected.mac;
    #endif

    if (macPtr) {
      String mac = macToString(macPtr);
      upsertDeviceSeen(mac);
    }
  }
}

// ---------- LED PWM Blink ----------
uint32_t blinkStartMs = 0;

void setupLedPwm() {
#if defined(ESP_ARDUINO_VERSION) && (ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0))
  // ESP32 core 3.x: channel auto-assigned; API is pin-based
  bool ok = ledcAttach((uint8_t)LED_BUILTIN, PWM_FREQ_HZ, PWM_RES_BITS);  // :contentReference[oaicite:1]{index=1}
  if (!ok) Serial.println("LEDC attach failed!");
  ledcWrite((uint8_t)LED_BUILTIN, 0);  // :contentReference[oaicite:2]{index=2}
#else
  // ESP32 core 2.x: classic channel-based API
  ledcSetup(PWM_CHANNEL, PWM_FREQ_HZ, PWM_RES_BITS);
  ledcAttachPin(LED_BUILTIN, PWM_CHANNEL);
  ledcWrite(PWM_CHANNEL, 0);
#endif
  blinkStartMs = millis();
}

void updateBlink() {
  uint32_t now = millis();
  uint32_t elapsed = (now - blinkStartMs) % BLINK_PERIOD_MS;

#if defined(ESP_ARDUINO_VERSION) && (ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0))
  // core 3.x uses pin in ledcWrite()
  ledcWrite((uint8_t)LED_BUILTIN, (elapsed < ON_TIME_MS) ? (255 - HALF_DUTY) : 255);
#else
  // core 2.x uses channel in ledcWrite()
  ledcWrite(PWM_CHANNEL, (elapsed < ON_TIME_MS) ? (255 - HALF_DUTY) : 255);
#endif
}

// ---------- Setup / Loop ----------
void setup() {
  Serial.begin(115200);
  delay(200);

  // SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS mount failed!");
  } else {
    loadDevicesFromSPIFFS();
    loadUsersFromSPIFFS();
    loadNodeLocFromSPIFFS();
    if (!SPIFFS.exists(MESSAGES_FILE)) {
      File nf = SPIFFS.open(MESSAGES_FILE, FILE_WRITE);
      if (nf) nf.close();
    }
  }

  // LED
  setupLedPwm();

  // WiFi AP
  WiFi.mode(WIFI_AP);
  WiFi.onEvent(WiFiEvent);

  WiFi.softAPConfig(apIP, gateway, subnet);

  bool ok = WiFi.softAP(AP_SSID); // open network (no password)
  Serial.print("SoftAP start: ");
  Serial.println(ok ? "OK" : "FAIL");
  Serial.print("AP IP: ");
  Serial.println(WiFi.softAPIP());

  // DNS wildcard to force captive portal
  dnsServer.start(53, "*", WiFi.softAPIP());

  // Web routes
  server.on("/", HTTP_GET, handleRoot);
  server.on("/data", HTTP_GET, handleData);
  server.on("/chat", HTTP_POST, handleChatPost);
  server.on("/me", HTTP_GET, handleMe);
  server.on("/setname", HTTP_POST, handleSetName);
  server.on("/setloc", HTTP_POST, handleSetLoc);

  // Common captive portal detection URLs
  server.on("/generate_204", HTTP_GET, handleCaptiveEndpoints);            // Android
  server.on("/gen_204", HTTP_GET, handleCaptiveEndpoints);
  server.on("/hotspot-detect.html", HTTP_GET, handleCaptiveEndpoints);     // Apple
  server.on("/library/test/success.html", HTTP_GET, handleCaptiveEndpoints); // Apple
  server.on("/ncsi.txt", HTTP_GET, handleCaptiveEndpoints);                // Windows
  server.on("/connecttest.txt", HTTP_GET, handleCaptiveEndpoints);         // Windows
  server.on("/success.txt", HTTP_GET, handleCaptiveEndpoints);

  server.onNotFound(handleNotFound);
  server.begin();

  Serial.println("HTTP server started.");
}

void loop() {
  updateBlink();
  dnsServer.processNextRequest();
  server.handleClient();
}
